// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async setTheme(theme: AppTheme): Promise<void> {
    await TAURI_INVOKE("set_theme", { theme });
  },
  async takePendingNavigation(): Promise<string | null> {
    return await TAURI_INVOKE("take_pending_navigation");
  },
  async requestPermission(permission: OSPermission): Promise<void> {
    await TAURI_INVOKE("request_permission", { permission });
  },
  async checkOsPermissions(initialCheck: boolean): Promise<OSPermissionsCheck> {
    return await TAURI_INVOKE("check_os_permissions", { initialCheck });
  },
  async openPermissionSettings(permission: OSPermission): Promise<void> {
    await TAURI_INVOKE("open_permission_settings", { permission });
  },
  async setHotkey(action: HotkeyAction, hotkey: Hotkey | null): Promise<null> {
    return await TAURI_INVOKE("set_hotkey", { action, hotkey });
  },
  async startDictating(): Promise<null> {
    return await TAURI_INVOKE("start_dictating");
  },
  async startVoiceDiary(): Promise<null> {
    return await TAURI_INVOKE("start_voice_diary");
  },
  async cancelDictating(): Promise<null> {
    return await TAURI_INVOKE("cancel_dictating");
  },
  async stopDictating(): Promise<TranscriptionResult> {
    return await TAURI_INVOKE("stop_dictating");
  },
  /**
   * 显示居于屏幕底部的全局 Notification，并在数秒后自动关闭
   */
  async showNotification(
    message: string,
    notificationType: NotificationType,
    offsetX: number | null,
  ): Promise<null> {
    return await TAURI_INVOKE("show_notification", {
      message,
      notificationType,
      offsetX,
    });
  },
  /**
   * 隐藏通知窗口
   */
  async hideNotification(): Promise<null> {
    return await TAURI_INVOKE("hide_notification");
  },
  /**
   * 获取开机自启动状态
   */
  async getAutostartEnabled(): Promise<boolean> {
    return await TAURI_INVOKE("get_autostart_enabled");
  },
  /**
   * 设置开机自启动
   */
  async setAutostartEnabled(enabled: boolean): Promise<null> {
    return await TAURI_INVOKE("set_autostart_enabled", { enabled });
  },
  /**
   * Onboarding 已完成
   */
  async setOnboardingCompleted(completed: boolean): Promise<boolean> {
    return await TAURI_INVOKE("set_onboarding_completed", { completed });
  },
  async testLlmApiKey(
    model: string | null,
    provider: string | null,
    apiKey: string | null,
  ): Promise<null> {
    return await TAURI_INVOKE("test_llm_api_key", { model, provider, apiKey });
  },
  async getSupportedModels(): Promise<SupportedModels> {
    return await TAURI_INVOKE("get_supported_models");
  },
  async getModelsStore(): Promise<ModelsStore> {
    return await TAURI_INVOKE("get_models_store");
  },
  async setActiveTextModel(modelId: string): Promise<ModelsStore> {
    return await TAURI_INVOKE("set_active_text_model", { modelId });
  },
  async updateTextModelCredentials(
    modelId: string,
    providerId: string,
    apiKey: string | null,
  ): Promise<ModelsStore> {
    return await TAURI_INVOKE("update_text_model_credentials", {
      modelId,
      providerId,
      apiKey,
    });
  },
  async setActiveAsrModel(modelId: string): Promise<ModelsStore> {
    return await TAURI_INVOKE("set_active_asr_model", { modelId });
  },
  async updateAsrCredentials(
    modelId: string,
    providerId: string,
    appId: string | null,
    accessToken: string | null,
  ): Promise<ModelsStore> {
    return await TAURI_INVOKE("update_asr_credentials", {
      modelId,
      providerId,
      appId,
      accessToken,
    });
  },
  async getOfflineModelsStatus(): Promise<OfflineModelsStatus> {
    return await TAURI_INVOKE("get_offline_models_status");
  },
  async downloadOfflineModels(modelId: string): Promise<OfflineModelsStatus> {
    return await TAURI_INVOKE("download_offline_models", { modelId });
  },
  async listHistoryEntries(
    filter: HistoryListFilter | null,
  ): Promise<HistoryEntry[]> {
    return await TAURI_INVOKE("list_history_entries", { filter });
  },
  async addHistoryEntry(entry: NewHistoryEntry): Promise<HistoryEntry> {
    return await TAURI_INVOKE("add_history_entry", { entry });
  },
  async deleteHistoryEntry(id: string): Promise<null> {
    return await TAURI_INVOKE("delete_history_entry", { id });
  },
  async clearHistoryEntries(): Promise<null> {
    return await TAURI_INVOKE("clear_history_entries");
  },
  async getHistoryStats(): Promise<HistoryStats> {
    return await TAURI_INVOKE("get_history_stats");
  },
  async loadHistoryAudio(path: string): Promise<string> {
    return await TAURI_INVOKE("load_history_audio", { path });
  },
};

/** user-defined events **/

export const events = __makeEvents__<{
  onEscapePress: OnEscapePress;
  onTranscribingStage: OnTranscribingStage;
  showNotification: ShowNotification;
}>({
  onEscapePress: "on-escape-press",
  onTranscribingStage: "on-transcribing-stage",
  showNotification: "show-notification",
});

/** user-defined constants **/

/** user-defined types **/

export type AppTheme = "system" | "light" | "dark";
export type AsrModelConfig = {
  id: string;
  title: string;
  offline?: boolean;
  size: string;
  providers?: AsrProviderConfig[];
};
export type AsrModelStore = {
  id: string;
  modelId?: string;
  provider: string;
  appId?: string | null;
  accessToken?: string | null;
  offline?: boolean;
  active?: boolean;
  totalRequests?: number;
  totalHours?: number;
};
export type AsrProviderConfig = {
  id: string;
  name: string;
  model?: string | null;
};
export type AudioState = "idle" | "recording" | "transcribing";
export type HistoryEntry = {
  id: string;
  title: string | null;
  text: string;
  kind: HistoryKind;
  createdAt: string;
  durationSeconds: number;
  audioFilePath: string | null;
  llmModel: string | null;
  llmVariantId: string | null;
  asrModel: string | null;
  asrVariantId: string | null;
  totalWords: number;
  totalTokens: number;
  llmTotalTokens: number | null;
  sourceApp: string | null;
  llmPolishStatus: LlmPolishStatus;
  llmPolishError: string | null;
};
export type HistoryKind = "dictation" | "diary";
export type HistoryListFilter = {
  kind?: HistoryKind | null;
  limit?: number | null;
  offset?: number | null;
};
export type HistoryStats = {
  totalEntries: number;
  totalWords: number;
  totalDurationSeconds: number;
  totalAppsUsed: number;
};
export type Hotkey = {
  code: string;
  meta: boolean;
  ctrl: boolean;
  alt: boolean;
  shift: boolean;
};
export type HotkeyAction = "startDictating" | "startVoiceDiary" | "other";
export type HotkeysStore = {
  hotkeys: Partial<{ [key in HotkeyAction]: Hotkey }>;
};
export type LlmModelConfig = {
  id: string;
  title: string;
  providers?: LlmProviderConfig[];
};
export type LlmModelStore = {
  id: string;
  textModelId?: string;
  provider: string;
  apiKey?: string | null;
  freeTotalRequests?: number;
  freeTotalTokenUsage?: number;
  totalRequests?: number;
  totalTokenUsage?: number;
  active?: boolean;
  usageDate?: string | null;
};
export type LlmPolishStatus =
  | "success"
  | "skipped"
  | "quotaExceeded"
  | "failed";
export type LlmProviderConfig = {
  id: string;
  name: string;
  model?: string | null;
  apiKeyUrl?: string | null;
  apiBaseUrl?: string | null;
  apiKeyEnv?: string | null;
};
export type ModelsStore = {
  llmModels?: LlmModelStore[];
  activeLlmModel?: string | null;
  asrModels?: AsrModelStore[];
  activeAsrModel?: string | null;
};
export type NewHistoryEntry = {
  id?: string | null;
  text: string;
  kind: HistoryKind;
  title?: string | null;
  durationSeconds?: number;
  createdAt?: string | null;
  audioFilePath?: string | null;
  llmModel?: string | null;
  llmVariantId?: string | null;
  asrModel?: string | null;
  asrVariantId?: string | null;
  totalWords?: number | null;
  totalTokens?: number | null;
  llmTotalTokens?: number | null;
  sourceApp?: string | null;
  llmPolishStatus?: LlmPolishStatus;
  llmPolishError?: string | null;
};
export type NotificationType = "error" | "info";
export type OSPermission = "microphone" | "accessibility";
export type OSPermissionStatus = "notNeeded" | "empty" | "granted" | "denied";
export type OSPermissionsCheck = {
  microphone: OSPermissionStatus;
  accessibility: OSPermissionStatus;
};
export type OfflineAsrModelStatus = {
  id: string;
  title: string;
  ready: boolean;
  missingFiles: string[];
  installDir: string;
};
export type OfflineModelsStatus = {
  ready: boolean;
  missingFiles: string[];
  installDir: string;
  models: OfflineAsrModelStatus[];
};
export type OnEscapePress = null;
export type OnTranscribingStage = { stage: TranscribingStage };
export type SettingsStore = {
  theme?: AppTheme;
  llmSystemPrompt?: string | null;
  autostartEnabled?: boolean;
  onboardingCompleted?: boolean;
};
export type ShowNotification = { message: string; type: NotificationType };
export type SupportedModels = {
  llmModels: LlmModelConfig[];
  asrModels: AsrModelConfig[];
};
export type TranscribingStage = "asr" | "polishing";
export type TranscriptionResult = {
  text: string;
  durationMs: number | null;
  utterances: TranscriptionUtterance[];
  llmPolishStatus?: LlmPolishStatus;
  llmPolishError?: string | null;
};
export type TranscriptionUtterance = {
  text: string;
  startTime: number;
  endTime: number;
};

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE } from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: "ok"; data: T }
  | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>;
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case "listen":
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case "once":
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case "emit":
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    },
  );
}
